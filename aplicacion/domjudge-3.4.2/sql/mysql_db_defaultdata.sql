-- These are default entries for the DOMjudge database, required for
-- correct functioning.
--
-- You can pipe this file into the 'mysql' command to insert this
-- data, but preferably use 'dj-setup-database'. Database should be set
-- externally (e.g. to 'domjudge').


-- 
-- Dumping data for table `configuration`
-- 

INSERT INTO `configuration` (`name`, `value`, `type`, `description`) VALUES ('compile_time', '30', 'int', 'Maximum seconds available for compiling.');
INSERT INTO `configuration` (`name`, `value`, `type`, `description`) VALUES ('memory_limit', '524288', 'int', 'Maximum memory usage (in kB) by submissions. This includes the shell which starts the compiled solution and also any interpreter like the Java VM, which takes away approx. 300MB!');
INSERT INTO `configuration` (`name`, `value`, `type`, `description`) VALUES ('filesize_limit', '4096', 'int', 'Maximum filesize (in kB) submissions may write. Solutions will abort when trying to write more, so this should be greater than the maximum testdata output.');
INSERT INTO `configuration` (`name`, `value`, `type`, `description`) VALUES ('process_limit', '15', 'int', 'Maximum number of processes that the submission is allowed to start (including shell and possibly interpreters).');
INSERT INTO `configuration` (`name`, `value`, `type`, `description`) VALUES ('sourcesize_limit', '256', 'int', 'Maximum source code size (in kB) of a submission. This setting should be kept in sync with that in "etc/submit-config.h.in".');
INSERT INTO `configuration` (`name`, `value`, `type`, `description`) VALUES ('sourcefiles_limit', '100', 'int', 'Maximum number of source files in one submission. Set to one to disable multiple file submissions.');
INSERT INTO `configuration` (`name`, `value`, `type`, `description`) VALUES ('verification_required', '0', 'bool', 'Is verification of judgings by jury required before publication?');
INSERT INTO `configuration` (`name`, `value`, `type`, `description`) VALUES ('show_affiliations', '1', 'bool', 'Show affiliations names and icons in the scoreboard?');
INSERT INTO `configuration` (`name`, `value`, `type`, `description`) VALUES ('show_pending', '0', 'bool', 'Show pending submissions on the scoreboard?');
INSERT INTO `configuration` (`name`, `value`, `type`, `description`) VALUES ('show_compile', '2', 'int', 'Show compile output in team webinterface? Choices: 0 = never, 1 = only on compilation error(s), 2 = always.');
INSERT INTO `configuration` (`name`, `value`, `type`, `description`) VALUES ('show_balloons_postfreeze', '0', 'bool', 'Give out balloon notifications after the scoreboard has been frozen?');
INSERT INTO `configuration` (`name`, `value`, `type`, `description`) VALUES ('penalty_time', '20', 'int', 'Penalty time in minutes per wrong submission (if finally solved).');
INSERT INTO `configuration` (`name`, `value`, `type`, `description`) VALUES ('results_prio', '{"memory-limit":99,"output-limit":99,"run-error":99,"timelimit":99,"wrong-answer":30,"presentation-error":20,"no-output":10,"correct":1}', 'array_keyval', 'Priorities of results for determining final result with multiple testcases. Higher priority is used first as final result. With equal priority, the first occurring result determines the final result.');
INSERT INTO `configuration` (`name`, `value`, `type`, `description`) VALUES ('results_remap', '{"presentation-error":"presentation-error"}', 'array_keyval', 'Remap testcase result, e.g. to disable a specific result type such as ''presentation-error''.');
INSERT INTO `configuration` (`name`, `value`, `type`, `description`) VALUES ('lazy_eval_results', '1', 'bool', 'Lazy evaluation of results? If enabled, stops judging as soon as a highest priority result is found, otherwise always all testcases will be judged.');
INSERT INTO `configuration` (`name`, `value`, `type`, `description`) VALUES ('enable_printing', '0', 'bool', 'Enable teams and jury to send source code to a printer via the DOMjudge web interface.');
INSERT INTO `configuration` (`name`, `value`, `type`, `description`) VALUES ('time_format', '"H:i"', 'string', 'The format used to print times. For formatting options see the PHP \'date\' function.');

-- 
-- Dumping data for table `contest`
--
INSERT INTO `contest` (`cid`, `contestname`,                                    `activatetime`,         `starttime`,            `freezetime`,       `endtime`,             `unfreezetime`, `activatetime_string`, `freezetime_string`, `endtime_string`, `unfreezetime_string`, `enabled`) VALUES 
                        (2, '!!Do not Delete Ever¡¡ Moodle Submission Contest', '2014-01-01 11:30:00', '2014-01-01 11:30:00', '2099-01-01 10:30:00', '2099-01-01 11:30:00', '2099-01-01 12:30:00', '2014-01-01 11:30:00', NULL, '2099-01-01 11:30:00', NULL, 1);

-- 
-- Dumping data for table `documentation_style`
--
INSERT INTO `documentation_style` (`name`, `author`, `version`, `copyright`, `license`, `package`, `param`, `retrn`, `param_pub`, `return_pub`, `see`, `documentation_styleid`, `langid`, `owner`) VALUES ('default', 1, 1, NULL, 1, NULL, 0, 0, 0, 0, 0, 1, 'scheme', -1);
INSERT INTO `documentation_style` (`name`, `author`, `version`, `copyright`, `license`, `package`, `param`, `retrn`, `param_pub`, `return_pub`, `see`, `documentation_styleid`, `langid`, `owner`) VALUES ('default', 1, 1, NULL, 1, NULL, 0, 0, 0, 0, 0, 2, 'java', -1);
INSERT INTO `documentation_style` (`name`, `author`, `version`, `copyright`, `license`, `package`, `param`, `retrn`, `param_pub`, `return_pub`, `see`, `documentation_styleid`, `langid`, `owner`) VALUES ('default', 1, 1, NULL, 1, NULL, 0, 0, 0, 0, 0, 3, 'cpp', -1);
-- 
-- Dumping data for table `indentation_style`
--
INSERT INTO `indentation_style` (`indentation_styleid`, `langid`, `name`, `sample`) VALUES
(1, 'cpp', 'gnu', '#include <a.h>\n#include <a.h>\n#include <a.h>\n\nusing namespace a.b.c a;\n\nstatic char *int\nconcat (char *s1, char *s2)\n{\n  while (x == y)\n    {\n      something ();\n      somethingelse ();\n    }\n  finalthing ();\n}\n\nextern struct x y;\n\nstatic const class Example:Int1, Int2, Int3\n{\npublic:\n  Example::~Example ():S1 (), S2 (), S3 ()\n  {\n    // if statements with empty braces\n    if (x)\n      {\n      }\n    else if (x)\n      {\n      }\n    else\n      {\n      }\n\n    // if statements with exactly one braced statement\n    if (x)\n      {\n        statement;\n      }\n    else if (x)\n      {\n        statement;\n      }\n    else\n      {\n        statement;\n      }\n\n    // special ''if'' cases\n    if (x)\n      {\n        statement;\n      }\n    else\n      {\n        statement;\n      }\n\n    if (x)\n      {\n        statement;\n\n        statement;\n      }\n    else\n      {\n        statement;\n\n        statement;\n      }\n\n    // if statements with a single implicit substatement\n    if (x)\n      statement;\n\n    else if (x)\n      statement;\n\n    else\n      statement;\n\n    // if statements with multiple statements\n    if (x)\n      {\n        statement;\n\n        statement;\n      }\n    else if (x)\n      {\n        statement;\n\n        statement;\n      }\n    else\n      {\n        statement;\n\n        statement;\n      }\n\n    // while statements with a single implicit substatement\n    while (x)\n      statement;\n\n    // while statements with a single implicit ''if'' substatement\n    while (x)\n      if (x)\n        statement;\n\n    // while with multiple statements\n    while (x)\n      {\n        statement;\n\n        statement;\n      }\n\n    // labeled statement\n  label:\n    statement;\n\n    // for statements with a single braced statement\n    for (x; x; x)\n      {\n        statement;\n      }\n\n    // do statements with a single braced substatement\n    do\n      {\n        statement;\n      }\n    while (false);\n\n    // do statement with an empty block\n    do\n      {\n      }\n    while (x);\n\n    // local blocks\n    {\n      statement;\n    }\n\n    /* Switch blocks:\n     *\n     * You can have case substatements be aligned by giving an example like:\n     *\n     * case 1: statement;\n     *\n     *         statement;\n     *\n     *         statement;\n     *\n     *         etc...\n     */\n    switch (c)\n      {\n      case 1:\n      case 2:\n      case 3:\n        statement;\n\n        statement;\n\n        statement;\n\n      case 4:\n        break;                  // case with exactly one substatement\n\n      default:\n        break;\n      }\n  }\n\n  void method (const myClass < item > &x, int[][][]c, ...)\n  {\n    // try-catch-finally with empty bodies\n    try\n    {\n    }\n    catch (Throwable e)\n    {\n    }\n    finally\n    {\n    }\n\n    // try-catch-finally with exactly one statement\n    try\n    {\n      statement;\n    }\n    catch (Throwable t)\n    {\n      statement;\n    }\n    finally\n    {\n      statement;\n    }\n\n    // try-catch-finally with multiple statements\n    try\n    {\n      statement;\n\n      statement;\n    }\n    catch (Throwable e)\n    {\n      statement;\n\n      statement;\n    }\n    finally\n    {\n      statement;\n\n      statement;\n\n      statement;\n    }\n  }\n};\n\n// enum statement\nstatic typedef enum x\n{\n  x,\n  y,\n  z,\n};\n\n// simple typedef\ntypedef interface static short int x;\n\nnamespace x\n{\n// template header\n  template < class T > x y z v () const;\n\n// pure virtual function, using c-style formal parameters with double parens\n  void v (()) = 0;\n\n// function with one single line statement and c-style formal parameters\n  void v ((int i))\n  {\n    statement;\n  };\n\n// function with no statements\n  myClass < myType >::method ()\n  {\n  }\n};\n\ntemplate < T > class x\n{\npublic:\n\n  // operator declarations\n  int operator + ();\n\n  int operator [] ();\n\n  // template method\n  static void A < x >::method ()[][][]\n  {\n    asm\n    {\n    -Assembler statements -\n        The outside braces are formatted but the asm\n        code is passed through unchanged.}\n\n  asm Single line assembler statements are also just passed through}\n  extern void oldStyleFunction () int a;\n  int b;\n  int c;\n  {\n    // various simple statements\n    long int a, b, c;\n\n    long double[] i;\n\n    goto x;\n\n    delete[]x;\n\n    delete[][][]x;\n\n    return x;\n\n    continue label;\n\n    throw e;\n\n    // c-style function calls with double parens\n    b ((a, b, c));\n\n    a (());\n\n    // expressions\n    new Object ()->field.method ();\n\n    s = "string" "split across lines";\n\n    method (a, B::C, ''d'');\n\n    z = j[0][0][0] || k * 3 >> ++i + "0" > i++ & (i) == !j;\n\n    int *v;\n\n    int &v;\n\n    x = x ** x;\n\n    (int *) x;\n\n    int (*functionPointer) (x, y, z);\n\n    h[0] += a ? b : ((int) c).d;\n\n    new Handler ();\n  }\n} a, b, c;                      // struct instances\n\nclass Class2\n{\n  /* Array creation with multiple non-array elements.\n   *\n   * If you give this example with the elements on the same line, then\n   * Polystyle will automatically vertically align them into a grid when it\n   * fits your code to the page. An alternate style is to have each\n   * element on its own line, like this:\n   * {\n   * x,\n   * y\n   * z\n   * }\n   */\n  boolean *bools1 = {\n    x, y, z\n  };\n\n// array creation with a single element\n  boolean bools2 = { x };\n\n// array creation with no elements\n  boolean bools3 = { };\n\n// multidimensional array creation\n  const int ***array = {\n    {1, 2, 3},\n    {1, 2, 3},\n    {1, 2, 3},\n  };\n};\n\n#if x\n\n#define x\n\n#elif a\n\n#define x\n\n#else\n\n#define x\n\n#define x\n\n#define x\n\n#endif\n\n// see if multi line macros are safely handled:\n#define multilinemacro do { x= x+5; } while (0); \\\nprintf("a multilinemacro"); \\\nprintf("a multilinemacro2");\n'),
(2, 'cpp', 'linux', '//Linux styles uses double tab means 8 spaces\n#include <a.h>\n#include <a.h>\n#include <a.h>\n\nusing namespace a.b.c a;\n\nstatic char *int concat(char *s1, char *s2)\n{\n        while (x == y) {\n                something();\n                somethingelse();\n        }\n        finalthing();\n}\n\nextern struct x y;\n\nstatic const class Example:Int1, Int2, Int3 {\n public:\n        Example::~Example():S1(), S2(), S3() {\n                // if statements with empty braces\n                if (x) {\n                } else if (x) {\n                } else {\n                }\n\n                // if statements with exactly one braced statement\n                if (x) {\n                        statement;\n                } else if (x) {\n                        statement;\n                } else {\n                        statement;\n                }\n\n                // special ''if'' cases\n                if (x) {\n                        statement;\n                } else {\n                        statement;\n                }\n\n                if (x) {\n                        statement;\n\n                        statement;\n                } else {\n                        statement;\n\n                        statement;\n                }\n\n                // if statements with a single implicit substatement\n                if (x)\n                        statement;\n\n                else if (x)\n                        statement;\n\n                else\n                        statement;\n\n                // if statements with multiple statements\n                if (x) {\n                        statement;\n\n                        statement;\n                } else if (x) {\n                        statement;\n\n                        statement;\n                } else {\n                        statement;\n\n                        statement;\n                }\n\n                // while statements with a single implicit substatement\n                while (x)\n                        statement;\n\n                // while statements with a single implicit ''if'' substatement\n                while (x)\n                        if (x)\n                                statement;\n\n                // while with multiple statements\n                while (x) {\n                        statement;\n\n                        statement;\n                }\n\n                // labeled statement\n label:\n                statement;\n\n                // for statements with a single braced statement\n                for (x; x; x) {\n                        statement;\n                }\n\n                // do statements with a single braced substatement\n                do {\n                        statement;\n                }\n                while (false);\n\n                // do statement with an empty block\n                do {\n                }\n                while (x);\n\n                // local blocks\n                {\n                        statement;\n                }\n\n                /* Switch blocks:\n                 *\n                 * You can have case substatements be aligned by giving an example like:\n                 *\n                 * case 1: statement;\n                 *\n                 *         statement;\n                 *\n                 *         statement;\n                 *\n                 *         etc...\n                 */\n                switch (c) {\n                case 1:\n                case 2:\n                case 3:\n                        statement;\n\n                        statement;\n\n                        statement;\n\n                case 4:\n                        break;  // case with exactly one substatement\n\n                default:\n                        break;\n                }\n        }\n\n        void method(const myClass < item > &x, int[][][]c, ...) {\n                // try-catch-finally with empty bodies\n                try {\n                }\n                catch(Throwable e) {\n                }\n                finally {\n                }\n\n                // try-catch-finally with exactly one statement\n                try {\n                        statement;\n                }\n                catch(Throwable t) {\n                        statement;\n                }\n                finally {\n                        statement;\n                }\n\n                // try-catch-finally with multiple statements\n                try {\n                        statement;\n\n                        statement;\n                }\n                catch(Throwable e) {\n                        statement;\n\n                        statement;\n                }\n                finally {\n                        statement;\n\n                        statement;\n\n                        statement;\n                }\n        }\n};\n\n// enum statement\nstatic typedef enum x {\n        x,\n        y,\n        z,\n};\n\n// simple typedef\ntypedef interface static short int x;\n\nnamespace x {\n// template header\n        template < class T > x y z v() const;\n\n// pure virtual function, using c-style formal parameters with double parens\n        void v(()) = 0;\n\n// function with one single line statement and c-style formal parameters\n        void v((int i)) {\n                statement;\n        };\n\n// function with no statements\n        myClass < myType >::method() {\n        }\n};\n\ntemplate < T > class x {\n public:\n\n        // operator declarations\n        int operator +();\n\n        int operator [] ();\n\n        // template method\n        static void A < x >::method()[][][] {\n                asm {\n                -Assembler statements -\n                            The outside braces are formatted but the asm\n                            code is passed through unchanged.}\n\n        asm Single line assembler statements are also just passed through}\n            extern void oldStyleFunction() int a;\n        int b;\n        int c;\n        {\n                // various simple statements\n                long int a, b, c;\n\n                long double[] i;\n\n                goto x;\n\n                delete[]x;\n\n                delete[][][]x;\n\n                return x;\n\n                continue label;\n\n                throw e;\n\n                // c-style function calls with double parens\n                b((a, b, c));\n\n                a(());\n\n                // expressions\n                new Object()->field.method();\n\n                s = "string" "split across lines";\n\n                method(a, B::C, ''d'');\n\n                z = j[0][0][0] || k * 3 >> ++i + "0" > i++ & (i) == !j;\n\n                int *v;\n\n                int &v;\n\n                x = x ** x;\n\n                (int *)x;\n\n                int (*functionPointer) (x, y, z);\n\n                h[0] += a ? b : ((int)c).d;\n\n                new Handler();\n        }\n} a, b, c;                      // struct instances\n\nclass Class2 {\n        /* Array creation with multiple non-array elements.\n         *\n         * If you give this example with the elements on the same line, then\n         * Polystyle will automatically vertically align them into a grid when it\n         * fits your code to the page. An alternate style is to have each\n         * element on its own line, like this:\n         * {\n         * x,\n         * y\n         * z\n         * }\n         */\n        boolean *bools1 = {\n                x, y, z\n        };\n\n// array creation with a single element\n        boolean bools2 = { x };\n\n// array creation with no elements\n        boolean bools3 = { };\n\n// multidimensional array creation\n        const int ***array = {\n                {1, 2, 3},\n                {1, 2, 3},\n                {1, 2, 3},\n        };\n};\n\n#if x\n\n#define x\n\n#elif a\n\n#define x\n\n#else\n\n#define x\n\n#define x\n\n#define x\n\n#endif\n\n// see if multi line macros are safely handled:\n#define multilinemacro do { x= x+5; } while (0); \\\nprintf("a multilinemacro"); \\\nprintf("a multilinemacro2");\n'),
(3, 'cpp', 'bsd', '#include <a.h>\n#include <a.h>\n#include <a.h>\n\nusing namespace a.b.c a;\n\nstatic char    *int\nconcat(char *s1, char *s2)\n{\n    while (x == y) {\n        something();\n        somethingelse();\n    }\n    finalthing();\n}\n\nextern struct x y;\n\nstatic const class Example:Int1,\n                Int2,\n                Int3 {\n  public:\n    Example::~Example():S1(), S2(), S3() {\n        // if statements with empty braces\n        if (x) {\n        } else if       (x) {\n        } else {\n        }\n\n        // if statements with exactly one braced statement\n        if (x) {\n            statement;\n        } else if (x) {\n            statement;\n        } else {\n            statement;\n        }\n\n        // special ''if'' cases\n        if (x) {\n            statement;\n        } else {\n            statement;\n        }\n\n        if (x) {\n            statement;\n\n            statement;\n        } else {\n            statement;\n\n            statement;\n        }\n\n        // if statements with a single implicit substatement\n        if (x)\n            statement;\n\n        else if (x)\n            statement;\n\n        else\n            statement;\n\n        // if statements with multiple statements\n        if (x) {\n            statement;\n\n            statement;\n        } else if (x) {\n            statement;\n\n            statement;\n        } else {\n            statement;\n\n            statement;\n        }\n\n        // while statements with a single implicit substatement\n        while (x)\n            statement;\n\n        // while statements with a single implicit ''if'' substatement\n        while (x)\n            if (x)\n                statement;\n\n        // while with multiple statements\n        while (x) {\n            statement;\n\n            statement;\n        }\n\n        // labeled statement\n      label:\n        statement;\n\n        // for statements with a single braced statement\n        for (x; x; x) {\n            statement;\n        }\n\n        // do statements with a single braced substatement\n        do {\n            statement;\n        }\n        while (false);\n\n        // do statement with an empty block\n        do {\n        }\n        while (x);\n\n        // local blocks\n        {\n            statement;\n        }\n\n        /*\n         * Switch blocks: You can have case substatements be aligned by\n         * giving an example like: case 1: statement; statement;\n         * statement; etc... \n         */\n        switch (c) {\n        case 1:\n        case 2:\n        case 3:\n            statement;\n\n            statement;\n\n            statement;\n\n        case 4:\n            break;              // case with exactly one substatement\n\n        default:\n            break;\n        }\n    }\n\n    void            method(const myClass < item > &x, int[][][]c, ...) {\n        // try-catch-finally with empty bodies\n        try {\n        }\n        catch(Throwable e) {\n        }\n        finally {\n        }\n\n        // try-catch-finally with exactly one statement\n        try {\n            statement;\n        }\n        catch(Throwable t) {\n            statement;\n        }\n        finally {\n            statement;\n        }\n\n        // try-catch-finally with multiple statements\n        try {\n            statement;\n\n            statement;\n        }\n        catch(Throwable e) {\n            statement;\n\n            statement;\n        }\n        finally {\n            statement;\n\n            statement;\n\n            statement;\n        }\n    }\n};\n\n// enum statement\nstatic typedef enum x {\n    x,\n    y,\n    z,\n};\n\n// simple typedef\ntypedef interface static short int x;\n\nnamespace       x {\n    // template header\n    template < class T > x y z v() const;\n\n    // pure virtual function, using c-style formal parameters with double\n    // parens\n    void            v(()) = 0;\n\n    // function with one single line statement and c-style formal\n    // parameters\n    void            v((int i)) {\n        statement;\n    };\n\n    // function with no statements\n    myClass < myType >::method() {\n    }\n};\n\ntemplate < T > class x {\n  public:\n\n    // operator declarations\n    int             operator +();\n\n    int             operator [] ();\n\n    // template method\n    static void     A < x >::method()[][][] {\n        asm {\n        -Assembler statements -\n                The outside braces are formatted but the asm\n                code is passed through unchanged.}\n\n    asm Single line assembler statements are also just passed through}\n        extern void oldStyleFunction() int a;\n    int             b;\n    int             c;\n    {\n        // various simple statements\n        long int        a,\n                        b,\n                        c;\n\n        long double[]   i;\n\n        goto x;\n\n        delete[]x;\n\n        delete[][][]x;\n\n        return x;\n\n        continue        label;\n\n        throw           e;\n\n        // c-style function calls with double parens\n        b((a, b, c));\n\n        a(());\n\n        // expressions\n        new             Object()->field.method();\n\n        s = "string" "split across lines";\n\n        method(a, B::C, ''d'');\n\n        z = j[0][0][0] || k * 3 >> ++i + "0" > i++ & (i) == !j;\n\n        int            *v;\n\n        int            &v;\n\n        x = x ** x;\n\n        (int *) x;\n\n        int             (*functionPointer) (x, y, z);\n\n        h[0] += a ? b : ((int) c).d;\n\n        new             Handler();\n    }\n} a, b, c;                      // struct instances\n\nclass           Class2 {\n    /*\n     * Array creation with multiple non-array elements. If you give this\n     * example with the elements on the same line, then Polystyle will\n     * automatically vertically align them into a grid when it fits your\n     * code to the page. An alternate style is to have each element on its \n     * own line, like this: { x, y z } \n     */\n    boolean        *bools1 = {\n        x, y, z\n    };\n\n    // array creation with a single element\n    boolean         bools2 = { x };\n\n    // array creation with no elements\n    boolean         bools3 = { };\n\n    // multidimensional array creation\n    const int    ***array = {\n        {1, 2, 3},\n        {1, 2, 3},\n        {1, 2, 3},\n    };\n};\n\n#if x\n\n#define x\n\n#elif a\n\n#define x\n\n#else\n\n#define x\n\n#define x\n\n#define x\n\n#endif\n\n// see if multi line macros are safely handled:\n#define multilinemacro do { x= x+5; } while (0); \\\nprintf("a multilinemacro"); \\\nprintf("a multilinemacro2");\n'),
(5, 'cpp', 'default', '#include <a.h>\n#include <a.h>\n#include <a.h>\n\nusing namespace a.b.c a;\n\nstatic char *int concat(char *s1, char *s2)\n{\n    while (x == y) {\n        something();\n        somethingelse();\n    }\n    finalthing();\n}\n\nextern struct x y;\n\nstatic const class Example:Int1, Int2, Int3 {\n  public:\n    Example::~Example():S1(), S2(), S3() {\n        // if statements with empty braces\n        if (x) {\n        } else if (x) {\n        } else {\n        }\n\n        // if statements with exactly one braced statement\n        if (x) {\n            statement;\n        } else if (x) {\n            statement;\n        } else {\n            statement;\n        }\n\n        // special ''if'' cases\n        if (x) {\n            statement;\n        } else {\n            statement;\n        }\n\n        if (x) {\n            statement;\n\n            statement;\n        } else {\n            statement;\n\n            statement;\n        }\n\n        // if statements with a single implicit substatement\n        if (x)\n            statement;\n\n        else if (x)\n            statement;\n\n        else\n            statement;\n\n        // if statements with multiple statements\n        if (x) {\n            statement;\n\n            statement;\n        } else if (x) {\n            statement;\n\n            statement;\n        } else {\n            statement;\n\n            statement;\n        }\n\n        // while statements with a single implicit substatement\n        while (x)\n            statement;\n\n        // while statements with a single implicit ''if'' substatement\n        while (x)\n            if (x)\n                statement;\n\n        // while with multiple statements\n        while (x) {\n            statement;\n\n            statement;\n        }\n\n        // labeled statement\n      label:\n        statement;\n\n        // for statements with a single braced statement\n        for (x; x; x) {\n            statement;\n        }\n\n        // do statements with a single braced substatement\n        do {\n            statement;\n        }\n        while (false);\n\n        // do statement with an empty block\n        do {\n        }\n        while (x);\n\n        // local blocks\n        {\n            statement;\n        }\n\n        /*\n         * Switch blocks: You can have case substatements be aligned by\n         * giving an example like: case 1: statement; statement;\n         * statement; etc... \n         */\n        switch (c) {\n        case 1:\n        case 2:\n        case 3:\n            statement;\n\n            statement;\n\n            statement;\n\n        case 4:\n            break;              // case with exactly one substatement\n\n        default:\n            break;\n        }\n    }\n\n    void method(const myClass < item > &x, int[][][]c, ...) {\n        // try-catch-finally with empty bodies\n        try {\n        }\n        catch(Throwable e) {\n        }\n        finally {\n        }\n\n        // try-catch-finally with exactly one statement\n        try {\n            statement;\n        }\n        catch(Throwable t) {\n            statement;\n        }\n        finally {\n            statement;\n        }\n\n        // try-catch-finally with multiple statements\n        try {\n            statement;\n\n            statement;\n        }\n        catch(Throwable e) {\n            statement;\n\n            statement;\n        }\n        finally {\n            statement;\n\n            statement;\n\n            statement;\n        }\n    }\n};\n\n// enum statement\nstatic typedef enum x {\n    x,\n    y,\n    z,\n};\n\n// simple typedef\ntypedef interface static short int x;\n\nnamespace x {\n    // template header\n    template < class T > x y z v() const;\n\n    // pure virtual function, using c-style formal parameters with double\n    // parens\n    void v(()) = 0;\n\n    // function with one single line statement and c-style formal\n    // parameters\n    void v((int i)) {\n        statement;\n    };\n\n    // function with no statements\n    myClass < myType >::method() {\n    }\n};\n\ntemplate < T > class x {\n  public:\n\n    // operator declarations\n    int operator +();\n\n    int operator [] ();\n\n    // template method\n    static void A < x >::method()[][][] {\n        asm {\n        -Assembler statements -\n                The outside braces are formatted but the asm\n                code is passed through unchanged.}\n\n    asm Single line assembler statements are also just passed through}\n        extern void oldStyleFunction() int a;\n    int b;\n    int c;\n    {\n        // various simple statements\n        long int a, b, c;\n\n        long double[] i;\n\n        goto x;\n\n        delete[]x;\n\n        delete[][][]x;\n\n        return x;\n\n        continue label;\n\n        throw e;\n\n        // c-style function calls with double parens\n        b((a, b, c));\n\n        a(());\n\n        // expressions\n        new Object()->field.method();\n\n        s = "string" "split across lines";\n\n        method(a, B::C, ''d'');\n\n        z = j[0][0][0] || k * 3 >> ++i + "0" > i++ & (i) == !j;\n\n        int *v;\n\n        int &v;\n\n        x = x ** x;\n\n        (int *) x;\n\n        int (*functionPointer) (x, y, z);\n\n        h[0] += a ? b : ((int) c).d;\n\n        new Handler();\n    }\n} a, b, c;                      // struct instances\n\nclass Class2 {\n    /*\n     * Array creation with multiple non-array elements. If you give this\n     * example with the elements on the same line, then Polystyle will\n     * automatically vertically align them into a grid when it fits your\n     * code to the page. An alternate style is to have each element on its \n     * own line, like this: { x, y z } \n     */\n    boolean *bools1 = {\n        x, y, z\n    };\n\n    // array creation with a single element\n    boolean bools2 = { x };\n\n    // array creation with no elements\n    boolean bools3 = { };\n\n    // multidimensional array creation\n    const int ***array = {\n        {1, 2, 3},\n        {1, 2, 3},\n        {1, 2, 3},\n    };\n};\n\n#if x\n\n#define x\n\n#elif a\n\n#define x\n\n#else\n\n#define x\n\n#define x\n\n#define x\n\n#endif\n\n// see if multi line macros are safely handled:\n#define multilinemacro do { x= x+5; } while (0); \\\nprintf("a multilinemacro"); \\\nprintf("a multilinemacro2");\n'),
(6, 'java', 'default', '// This sample doesn''t compile but help''s but showing the differente code \n// snippets that help you keep the indentation style\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport javax.swing.JFrame;\n\npublic class sample extends JFrame implements Runnable {\n\n    String[] a = new String[] {\n        "Sunday",               // Sunday\n        "Monday",           // Monday\n        "Tuesday",          // Tuesday\n        "Wednesday",        // Wednesday\n        "Thursday",         // Thursday\n        "Friday",           // Friday\n        "Saturday"          // Saturday\n    };\n\n    private sample() {\n    }\n\n    void foo() {\n        while (bar > 0) {\n            System.out.println();\n            bar--;\n        }\n\n        if (oatmeal == tasty) {\n            System.out.println("Oatmeal is good and good for you");\n        } else if (oatmeal == yak) {\n            System.out.println("Oatmeal tastes like sawdust");\n        } else {\n            System.out.println("tell me pleeze what iz dis ''oatmeal''");\n        }\n\n        switch (suckFactor) {\n        case 1:\n            System.out.println("This sucks");\n            break;\n        case 2:\n            System.out.println("This really sucks");\n            break;\n        case 3:\n            System.out.println("This seriously sucks");\n            break;\n        default:\n            System.out.println("whatever");\n            break;\n        }\n\n        if (superHero == theTick) {\n            System.out.println("Spoon!");\n        }\n\n        foo(i, j);\n\n        a = b + c;\n        z = (2 * x) + (3 * y);\n        count++;\n        i--;\n\n        for (int i = 0; i < 10; i++) {\n            getPancakes(syrupQuantity, butterQuantity);\n        }\n\n        (MyClass) v.get(3);\n\n        if (hungry) {\n            while (pancakes < 7) {\n                for (int i = 0; i < 10; i++) {\n                    try {\n                    } catch(TooManyPancakesException e) {\n                    }\n                }\n\n            }\n        }\n\n        foo(x);                 // YES!\n        x++;\n\n        y += 100 * x;           // YES!\n        x++;\n\n        /*\n         * "Any fool can write code that a computer can understand. Good\n         * programmers write code that humans can understand." --- Martin\n         * Fowler, Refactoring: Improving the Design of Existing Code \n         */\n        int secondWide = 12;\n        int firstWide = doFoo(20, secondWide);\n        doBar(firstWide, secondWide);\n        int totalWide = firstWide + secondWide;\n\n    }\n\n    void tooLongMethod() {\n        boolean isTickSidekick = ((sidekick == arthur)\n                                  || (sidekick == speak));\n        if ((hero == theTick) && isTickSidekick) {\n        }\n    }\n\n    public static void happyBirthday(int age) { // WRONG!\n        // If you''re in the US, some birthdays are special:\n        // 16 (sweet sixteen)\n        // 21 (age of majority)\n        // 25, 50, 75 (quarter centuries)\n        // 30, 40, 50, ... etc (decades)\n        if ((age == 16) || (age == 21)\n            || ((age > 21) && (((age % 10) == 0) || ((age % 25) == 0)))) {\n            System.out.println("Super special party, this year!");\n        } else {\n            System.out.println("One year older. Again.");\n        }\n    }\n\n    public static void happyBirthday(int age) { // Right!\n        boolean sweet_sixteen = (age == 16);\n        boolean majority = (age == 21);\n        boolean adult = (age > 21);\n        boolean decade = (age % 10) == 0;\n        boolean quarter = (age % 25) == 0;\n\n        if (sweet_sixteen || majority || (adult && (decade || quarter))) {\n            System.out.println("Super special party, this year!");\n        } else {\n            System.out.println("One year older. Again.");\n        }\n    }\n\n    // This actualy work amazing for debuging\n    static void dbg(Object ... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n\n    static void callingDebug() {\n        dbg(3);\n        String[]b = new String[] {\n            "Sunday",           // Sunday\n            "Monday",       // Monday\n            "Tuesday",      // Tuesday\n            "Wednesday",    // Wednesday\n            "Thursday",     // Thursday\n            "Friday",       // Friday\n            "Saturday"      // Saturday\n        };\n        dbg(b);\n        HashMap < String, Person > ha = new HashMap < String, Person > ();\n        Person him = new Person().sFirstName = "civilian";\n        ha.put("Oscar", him);\n        dbg(ha);\n        // dbg(Whatever_i_want_as_long_as_the_objet_has_an_toString_method);\n\n    }\n\n    static class Person {\n\n        private String sFirstName;      // NO! (Hungarian notation: s for\n        // String)\n        private String firstName;       // YES!\n        private String mLastName;       // NO! (Scope identification: m\n        // for member variable)\n        private String _lastName;       // NO! (Scope identification: _\n        // for member variable)\n        private String lastName;        // YES!\n\n        // ...\n        @Override public String toString() {\n            return "Person{" + "sFirstName=" + sFirstName +\n                ", firstName=" + firstName + ", mLastName=" + mLastName +\n                ", _lastName=" + _lastName + ", lastName=" + lastName +\n                ''}'';\n        }\n    }\n    private static final File getDestinationFile(File dest,\n                                                 String packageName,\n                                                 String filename, int prio)\n        throws IOException, FooException {\n        switch (prio) {\n        case Priority.ERROR_INT:\n        case Priority.FATAL_INT:\n            color = Color.red;\n            break;\n\n        case Priority.WARN_INT:color = Color.blue;\n            break;\n\n        default:color = Color.black;\n            break;\n        }\n        return null;\n    }\n\n    public void severalParameters(String one, int two, String three,\n                                  StringObject four, AnotherObject five) {\n\n        if ((condition1 && condition2)\n            || (condition3 && condition4) || !(condition5 && condition6)) {\n            doSomethingAboutIt();\n        }\n\n        vector.add(new AppServerReference("RemoteApplicationManager",\n                                          poa.create_reference_with_id\n                                          ("RemoteApplicationManager".getBytes\n                                           (),\n                                           RemoteApplicationManagerHelper.id\n                                           ())));\n\n\n        doublette[InteressentenPflegeController.GEBURTSDATUM] =\n            versichertenResultSetRow[i].field[0].substring(0,\n                                                           2) + "."\n            + versichertenResultSetRow[i].field[0].substring(2,\n                                                             4) + "."\n            + versichertenResultSetRow[i].field[0].substring(4, 6);\n    }\n\n    public static void main(String[]argv) {\n        callingDebug();\n    }\n\n    @Override public void run() {\n        throw new UnsupportedOperationException("Not supported yet.");\n    }\n}\n'),
(7, 'scheme', 'default', ';;;\n;;; <primitiva>                     ::= +|-|*|/|%|&\n;;; <bool-primitiva>            ::= <|>|<=|>=|is \n;;; <bool-oper>                   ::= not|and|or\n\n\n; Comments bla bal\n; \n\n(define functi\n   (lambda (jogador carta)\n     (append (list (car jogador) (add1 (cadr jogador)) carta) (cddr jogador))\n     (if (figura-carta?-sol carta)\n       (let ((figura (valor-carta-sol carta)))\n         (cond\n          ((string=? figura "as") 13)\n          ((string=? figura "rei") 12)\n          ((string=? figura "valete") 11)\n          ((#t 10))))\n       (sub1 (valor-carta-sol carta)))))\n\n\n(define functi2 (lambda (var1 var2) (lambda (foo) "foo" "bar")))\n\n\n(define functiWhile (lambda (var1 var2) (while (foo) "foo" "bar")))\n\n\n(define functiIf (lambda (var1 var2) (if (foo) "foo" "bar")))\n\n\n;(define in (open-input-file (symbol->string (read) )))\n;(define data-file (symbol->string (read) ))\n;(define in (open-input-file data-file))\n;(define out (open-output-file data-file))\n;(define siz (file-size data-file) )\n\n(define (read-next-line-iter)\n   (let ((line (read)))\n     (unless (eof-object? line)\n       (pretty-print line)\n       (newline)\n       (read-next-line-iter))))\n\n\n\n;(write (pretty-print  (read-bytes siz in) ) (current-output-port))\n;(call-with-input-file data-file read-next-line-iter)\n(read-next-line-iter)\n\n\n(define naipe-jogador-sol\n   (lambda (jogador naipe)\n     (letrec ((aux\n               (lambda (cartas naipe num)\n                 (if (null? cartas)\n                   num\n                   (if (equal? naipe (naipe-carta-sol (car cartas)))\n                     (aux (cdr cartas) naipe (add1 num))\n                     (aux (cdr cartas) naipe num))))))\n       (aux (cddr jogador) naipe 0))))\n\n  \n(define (read-next-line-iter)\n   (if (or (eq? (peek-char) #\\() (eq? (peek-char) #\\[) (eq? (peek-char) #\\{))\n     (read_symbol)\n     (read_line)))\n'),
(8, 'cpp', 'kr', '#include <a.h>\n#include <a.h>\n#include <a.h>\n\nusing namespace a.b.c a;\n\nstatic char *int concat(char *s1, char *s2)\n{\n    while (x == y) {\n        something();\n        somethingelse();\n    }\n    finalthing();\n}\n\nextern struct x y;\n\nstatic const class Example:Int1, Int2, Int3 {\n  public:\n    Example::~Example():S1(), S2(), S3() {\n        // if statements with empty braces\n        if (x) {\n        } else if (x) {\n        } else {\n        }\n\n        // if statements with exactly one braced statement\n        if (x) {\n            statement;\n        } else if (x) {\n            statement;\n        } else {\n            statement;\n        }\n\n        // special ''if'' cases\n        if (x) {\n            statement;\n        } else {\n            statement;\n        }\n\n        if (x) {\n            statement;\n\n            statement;\n        } else {\n            statement;\n\n            statement;\n        }\n\n        // if statements with a single implicit substatement\n        if (x)\n            statement;\n\n        else if (x)\n            statement;\n\n        else\n            statement;\n\n        // if statements with multiple statements\n        if (x) {\n            statement;\n\n            statement;\n        } else if (x) {\n            statement;\n\n            statement;\n        } else {\n            statement;\n\n            statement;\n        }\n\n        // while statements with a single implicit substatement\n        while (x)\n            statement;\n\n        // while statements with a single implicit ''if'' substatement\n        while (x)\n            if (x)\n                statement;\n\n        // while with multiple statements\n        while (x) {\n            statement;\n\n            statement;\n        }\n\n        // labeled statement\n      label:\n        statement;\n\n        // for statements with a single braced statement\n        for (x; x; x) {\n            statement;\n        }\n\n        // do statements with a single braced substatement\n        do {\n            statement;\n        }\n        while (false);\n\n        // do statement with an empty block\n        do {\n        }\n        while (x);\n\n        // local blocks\n        {\n            statement;\n        }\n\n        /*\n         * Switch blocks: You can have case substatements be aligned by\n         * giving an example like: case 1: statement; statement;\n         * statement; etc... \n         */\n        switch (c) {\n        case 1:\n        case 2:\n        case 3:\n            statement;\n\n            statement;\n\n            statement;\n\n        case 4:\n            break;              // case with exactly one substatement\n\n        default:\n            break;\n        }\n    }\n\n    void method(const myClass < item > &x, int[][][]c, ...) {\n        // try-catch-finally with empty bodies\n        try {\n        }\n        catch(Throwable e) {\n        }\n        finally {\n        }\n\n        // try-catch-finally with exactly one statement\n        try {\n            statement;\n        }\n        catch(Throwable t) {\n            statement;\n        }\n        finally {\n            statement;\n        }\n\n        // try-catch-finally with multiple statements\n        try {\n            statement;\n\n            statement;\n        }\n        catch(Throwable e) {\n            statement;\n\n            statement;\n        }\n        finally {\n            statement;\n\n            statement;\n\n            statement;\n        }\n    }\n};\n\n// enum statement\nstatic typedef enum x {\n    x,\n    y,\n    z,\n};\n\n// simple typedef\ntypedef interface static short int x;\n\nnamespace x {\n    // template header\n    template < class T > x y z v() const;\n\n    // pure virtual function, using c-style formal parameters with double\n    // parens\n    void v(()) = 0;\n\n    // function with one single line statement and c-style formal\n    // parameters\n    void v((int i)) {\n        statement;\n    };\n\n    // function with no statements\n    myClass < myType >::method() {\n    }\n};\n\ntemplate < T > class x {\n  public:\n\n    // operator declarations\n    int operator +();\n\n    int operator [] ();\n\n    // template method\n    static void A < x >::method()[][][] {\n        asm {\n        -Assembler statements -\n                The outside braces are formatted but the asm\n                code is passed through unchanged.}\n\n    asm Single line assembler statements are also just passed through}\n        extern void oldStyleFunction() int a;\n    int b;\n    int c;\n    {\n        // various simple statements\n        long int a, b, c;\n\n        long double[] i;\n\n        goto x;\n\n        delete[]x;\n\n        delete[][][]x;\n\n        return x;\n\n        continue label;\n\n        throw e;\n\n        // c-style function calls with double parens\n        b((a, b, c));\n\n        a(());\n\n        // expressions\n        new Object()->field.method();\n\n        s = "string" "split across lines";\n\n        method(a, B::C, ''d'');\n\n        z = j[0][0][0] || k * 3 >> ++i + "0" > i++ & (i) == !j;\n\n        int *v;\n\n        int &v;\n\n        x = x ** x;\n\n        (int *) x;\n\n        int (*functionPointer) (x, y, z);\n\n        h[0] += a ? b : ((int) c).d;\n\n        new Handler();\n    }\n} a, b, c;                      // struct instances\n\nclass Class2 {\n    /*\n     * Array creation with multiple non-array elements. If you give this\n     * example with the elements on the same line, then Polystyle will\n     * automatically vertically align them into a grid when it fits your\n     * code to the page. An alternate style is to have each element on its \n     * own line, like this: { x, y z } \n     */\n    boolean *bools1 = {\n        x, y, z\n    };\n\n    // array creation with a single element\n    boolean bools2 = { x };\n\n    // array creation with no elements\n    boolean bools3 = { };\n\n    // multidimensional array creation\n    const int ***array = {\n        {1, 2, 3},\n        {1, 2, 3},\n        {1, 2, 3},\n    };\n};\n\n#if x\n\n#define x\n\n#elif a\n\n#define x\n\n#else\n\n#define x\n\n#define x\n\n#define x\n\n#endif\n\n// see if multi line macros are safely handled:\n#define multilinemacro do { x= x+5; } while (0); \\\nprintf("a multilinemacro"); \\\nprintf("a multilinemacro2");\n');
INSERT INTO `indentation_style` (`indentation_styleid`, `langid`, `name`, `sample`) VALUES
(9, 'java', 'gnu', '// This sample doesn''t compile but help''s but showing the differente code \n// snippets that help you keep the indentation style\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport javax.swing.JFrame;\n\npublic class sample extends JFrame implements Runnable\n{\n\n  String[] a = new String[]\n  {\n    "Sunday",                   // Sunday\n      "Monday",                 // Monday\n      "Tuesday",                // Tuesday\n      "Wednesday",              // Wednesday\n      "Thursday",               // Thursday\n      "Friday",                 // Friday\n      "Saturday"                // Saturday\n  };\n\n  private sample ()\n  {\n  }\n\n  void foo ()\n  {\n    while (bar > 0)\n      {\n        System.out.println ();\n        bar--;\n      }\n\n    if (oatmeal == tasty)\n      {\n        System.out.println ("Oatmeal is good and good for you");\n      }\n    else if (oatmeal == yak)\n      {\n        System.out.println ("Oatmeal tastes like sawdust");\n      }\n    else\n      {\n        System.out.println ("tell me pleeze what iz dis ''oatmeal''");\n      }\n\n    switch (suckFactor)\n      {\n      case 1:\n        System.out.println ("This sucks");\n        break;\n      case 2:\n        System.out.println ("This really sucks");\n        break;\n      case 3:\n        System.out.println ("This seriously sucks");\n        break;\n      default:\n        System.out.println ("whatever");\n        break;\n      }\n\n    if (superHero == theTick)\n      {\n        System.out.println ("Spoon!");\n      }\n\n    foo (i, j);\n\n    a = b + c;\n    z = (2 * x) + (3 * y);\n    count++;\n    i--;\n\n    for (int i = 0; i < 10; i++)\n      {\n        getPancakes (syrupQuantity, butterQuantity);\n      }\n\n    (MyClass) v.get (3);\n\n    if (hungry)\n      {\n        while (pancakes < 7)\n          {\n            for (int i = 0; i < 10; i++)\n              {\n                try\n                {\n                } catch (TooManyPancakesException e)\n                {\n                }\n              }\n\n          }\n      }\n\n    foo (x);                    // YES!\n    x++;\n\n    y += 100 * x;               // YES!\n    x++;\n\n    /*\n     * "Any fool can write code that a computer can understand. Good\n     * programmers write code that humans can understand." --- Martin\n     * Fowler, Refactoring: Improving the Design of Existing Code \n     */\n    int secondWide = 12;\n    int firstWide = doFoo (20, secondWide);\n    doBar (firstWide, secondWide);\n    int totalWide = firstWide + secondWide;\n\n  }\n\n  void tooLongMethod ()\n  {\n    boolean isTickSidekick = ((sidekick == arthur) || (sidekick == speak));\n    if ((hero == theTick) && isTickSidekick)\n      {\n      }\n  }\n\n  public static void happyBirthday (int age)\n  {                             // WRONG!\n    // If you''re in the US, some birthdays are special:\n    // 16 (sweet sixteen)\n    // 21 (age of majority)\n    // 25, 50, 75 (quarter centuries)\n    // 30, 40, 50, ... etc (decades)\n    if ((age == 16) || (age == 21)\n        || ((age > 21) && (((age % 10) == 0) || ((age % 25) == 0))))\n      {\n        System.out.println ("Super special party, this year!");\n      }\n    else\n      {\n        System.out.println ("One year older. Again.");\n      }\n  }\n\n  public static void happyBirthday (int age)\n  {                             // Right!\n    boolean sweet_sixteen = (age == 16);\n    boolean majority = (age == 21);\n    boolean adult = (age > 21);\n    boolean decade = (age % 10) == 0;\n    boolean quarter = (age % 25) == 0;\n\n    if (sweet_sixteen || majority || (adult && (decade || quarter)))\n      {\n        System.out.println ("Super special party, this year!");\n      }\n    else\n      {\n        System.out.println ("One year older. Again.");\n      }\n  }\n\n  // This actualy work amazing for debuging\n  static void dbg (Object ... o)\n  {\n    System.out.println (Arrays.deepToString (o));\n  }\n\n  static void callingDebug ()\n  {\n    dbg (3);\n    String[]b = new String[]\n    {\n      "Sunday",                 // Sunday\n        "Monday",               // Monday\n        "Tuesday",              // Tuesday\n        "Wednesday",            // Wednesday\n        "Thursday",             // Thursday\n        "Friday",               // Friday\n        "Saturday"              // Saturday\n    };\n    dbg (b);\n    HashMap < String, Person > ha = new HashMap < String, Person > ();\n    Person him = new Person ().sFirstName = "civilian";\n    ha.put ("Oscar", him);\n    dbg (ha);\n    // dbg(Whatever_i_want_as_long_as_the_objet_has_an_toString_method);\n\n  }\n\n  static class Person\n  {\n\n    private String sFirstName;  // NO! (Hungarian notation: s for\n    // String)\n    private String firstName;   // YES!\n    private String mLastName;   // NO! (Scope identification: m\n    // for member variable)\n    private String _lastName;   // NO! (Scope identification: _\n    // for member variable)\n    private String lastName;    // YES!\n\n    // ...\n     @Override public String toString ()\n    {\n      return "Person{" + "sFirstName=" + sFirstName +\n        ", firstName=" + firstName + ", mLastName=" + mLastName +\n        ", _lastName=" + _lastName + ", lastName=" + lastName + ''}'';\n    }\n  }\n  private static final File getDestinationFile (File dest,\n                                                String packageName,\n                                                String filename, int prio)\n    throws IOException, FooException\n  {\n    switch (prio)\n      {\n      case Priority.ERROR_INT:\n      case Priority.FATAL_INT:\n        color = Color.red;\n        break;\n\n        case Priority.WARN_INT:color = Color.blue;\n        break;\n\n        default:color = Color.black;\n        break;\n      }\n    return null;\n  }\n\n  public void severalParameters (String one, int two, String three,\n                                 StringObject four, AnotherObject five)\n  {\n\n    if ((condition1 && condition2)\n        || (condition3 && condition4) || !(condition5 && condition6))\n      {\n        doSomethingAboutIt ();\n      }\n\n    vector.add (new AppServerReference ("RemoteApplicationManager",\n                                        poa.create_reference_with_id\n                                        ("RemoteApplicationManager".getBytes\n                                         (),\n                                         RemoteApplicationManagerHelper.id\n                                         ())));\n\n\n    doublette[InteressentenPflegeController.GEBURTSDATUM] =\n      versichertenResultSetRow[i].field[0].substring (0,\n                                                      2) + "."\n      + versichertenResultSetRow[i].field[0].substring (2,\n                                                        4) + "."\n      + versichertenResultSetRow[i].field[0].substring (4, 6);\n  }\n\n  public static void main (String[]argv)\n  {\n    callingDebug ();\n  }\n\n  @Override public void run ()\n  {\n    throw new UnsupportedOperationException ("Not supported yet.");\n  }\n}\n'),
(10, 'java', 'linux', '// This sample doesn''t compile but help''s but showing the differente code \n// snippets that help you keep the indentation style\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport javax.swing.JFrame;\n\npublic class sample extends JFrame implements Runnable {\n\n        String[] a = new String[] {\n                "Sunday",       // Sunday\n                    "Monday",   // Monday\n                    "Tuesday",  // Tuesday\n                    "Wednesday",        // Wednesday\n                    "Thursday", // Thursday\n                    "Friday",   // Friday\n                    "Saturday"  // Saturday\n        };\n\n        private sample() {\n        }\n\n        void foo() {\n                while (bar > 0) {\n                        System.out.println();\n                        bar--;\n                }\n\n                if (oatmeal == tasty) {\n                        System.out.println("Oatmeal is good and good for you");\n                } else if (oatmeal == yak) {\n                        System.out.println("Oatmeal tastes like sawdust");\n                } else {\n                        System.out.\n                            println("tell me pleeze what iz dis ''oatmeal''");\n                }\n\n                switch (suckFactor) {\n                case 1:\n                        System.out.println("This sucks");\n                        break;\n                case 2:\n                        System.out.println("This really sucks");\n                        break;\n                case 3:\n                        System.out.println("This seriously sucks");\n                        break;\n                default:\n                        System.out.println("whatever");\n                        break;\n                }\n\n                if (superHero == theTick) {\n                        System.out.println("Spoon!");\n                }\n\n                foo(i, j);\n\n                a = b + c;\n                z = (2 * x) + (3 * y);\n                count++;\n                i--;\n\n                for (int i = 0; i < 10; i++) {\n                        getPancakes(syrupQuantity, butterQuantity);\n                }\n\n                (MyClass) v.get(3);\n\n                if (hungry) {\n                        while (pancakes < 7) {\n                                for (int i = 0; i < 10; i++) {\n                                        try {\n                                        } catch(TooManyPancakesException e) {\n                                        }\n                                }\n\n                        }\n                }\n\n                foo(x);         // YES!\n                x++;\n\n                y += 100 * x;   // YES!\n                x++;\n\n                /*\n                 * "Any fool can write code that a computer can understand. Good\n                 * programmers write code that humans can understand." --- Martin\n                 * Fowler, Refactoring: Improving the Design of Existing Code \n                 */\n                int secondWide = 12;\n                int firstWide = doFoo(20, secondWide);\n                doBar(firstWide, secondWide);\n                int totalWide = firstWide + secondWide;\n\n        }\n\n        void tooLongMethod() {\n                boolean isTickSidekick = ((sidekick == arthur)\n                                          || (sidekick == speak));\n                if ((hero == theTick) && isTickSidekick) {\n                }\n        }\n\n        public static void happyBirthday(int age) {     // WRONG!\n                // If you''re in the US, some birthdays are special:\n                // 16 (sweet sixteen)\n                // 21 (age of majority)\n                // 25, 50, 75 (quarter centuries)\n                // 30, 40, 50, ... etc (decades)\n                if ((age == 16) || (age == 21)\n                    || ((age > 21) && (((age % 10) == 0) || ((age % 25) == 0)))) {\n                        System.out.println("Super special party, this year!");\n                } else {\n                        System.out.println("One year older. Again.");\n                }\n        }\n\n        public static void happyBirthday(int age) {     // Right!\n                boolean sweet_sixteen = (age == 16);\n                boolean majority = (age == 21);\n                boolean adult = (age > 21);\n                boolean decade = (age % 10) == 0;\n                boolean quarter = (age % 25) == 0;\n\n                if (sweet_sixteen || majority || (adult && (decade || quarter))) {\n                        System.out.println("Super special party, this year!");\n                } else {\n                        System.out.println("One year older. Again.");\n                }\n        }\n\n        // This actualy work amazing for debuging\n        static void dbg(Object ... o) {\n                System.out.println(Arrays.deepToString(o));\n        }\n\n        static void callingDebug() {\n                dbg(3);\n                String[]b = new String[] {\n                        "Sunday",       // Sunday\n                            "Monday",   // Monday\n                            "Tuesday",  // Tuesday\n                            "Wednesday",        // Wednesday\n                            "Thursday", // Thursday\n                            "Friday",   // Friday\n                            "Saturday"  // Saturday\n                };\n                dbg(b);\n                HashMap < String, Person > ha =\n                    new HashMap < String, Person > ();\n                Person him = new Person().sFirstName = "civilian";\n                ha.put("Oscar", him);\n                dbg(ha);\n                // dbg(Whatever_i_want_as_long_as_the_objet_has_an_toString_method);\n\n        }\n\n        static class Person {\n\n                private String sFirstName;      // NO! (Hungarian notation: s for\n                // String)\n                private String firstName;       // YES!\n                private String mLastName;       // NO! (Scope identification: m\n                // for member variable)\n                private String _lastName;       // NO! (Scope identification: _\n                // for member variable)\n                private String lastName;        // YES!\n\n                // ...\n                @Override public String toString() {\n                        return "Person{" + "sFirstName=" + sFirstName +\n                            ", firstName=" + firstName + ", mLastName=" +\n                            mLastName + ", _lastName=" + _lastName +\n                            ", lastName=" + lastName + ''}'';\n        }} private static final File getDestinationFile(File dest,\n                                                        String packageName,\n                                                        String filename,\n                                                        int prio)\n        throws IOException, FooException {\n                switch (prio) {\n                case Priority.ERROR_INT:\n                case Priority.FATAL_INT:\n                        color = Color.red;\n                        break;\n\n                        case Priority.WARN_INT:color = Color.blue;\n                        break;\n\n                        default:color = Color.black;\n                        break;\n                } return null;\n        }\n\n        public void severalParameters(String one, int two, String three,\n                                      StringObject four, AnotherObject five) {\n\n                if ((condition1 && condition2)\n                    || (condition3 && condition4) || !(condition5\n                                                       && condition6)) {\n                        doSomethingAboutIt();\n                }\n\n                vector.add(new AppServerReference("RemoteApplicationManager",\n                                                  poa.create_reference_with_id\n                                                  ("RemoteApplicationManager".\n                                                   getBytes(),\n                                                   RemoteApplicationManagerHelper.\n                                                   id())));\n\n                doublette[InteressentenPflegeController.GEBURTSDATUM] =\n                    versichertenResultSetRow[i].field[0].substring(0,\n                                                                   2) + "."\n                    + versichertenResultSetRow[i].field[0].substring(2,\n                                                                     4) + "."\n                    + versichertenResultSetRow[i].field[0].substring(4, 6);\n        }\n\n        public static void main(String[]argv) {\n                callingDebug();\n        }\n\n        @Override public void run() {\n                throw new UnsupportedOperationException("Not supported yet.");\n        }\n}\n'),
(11, 'java', 'bsd', '// This sample doesn''t compile but help''s but showing the differente code \n// snippets that help you keep the indentation style\nimport          java.io.File;\nimport          java.io.IOException;\nimport          java.util.Arrays;\nimport          java.util.HashMap;\nimport          javax.swing.JFrame;\n\npublic class sample extends JFrame implements Runnable {\n\n    String[] a = new String[] {\n        "Sunday",               // Sunday\n            "Monday",           // Monday\n            "Tuesday",          // Tuesday\n            "Wednesday",        // Wednesday\n            "Thursday",         // Thursday\n            "Friday",           // Friday\n            "Saturday"          // Saturday\n    };\n\n    private         sample() {\n    }\n\n    void            foo() {\n        while (bar > 0) {\n            System.out.println();\n            bar--;\n        }\n\n        if (oatmeal == tasty) {\n            System.out.println("Oatmeal is good and good for you");\n        } else if (oatmeal == yak) {\n            System.out.println("Oatmeal tastes like sawdust");\n        } else {\n            System.out.println("tell me pleeze what iz dis ''oatmeal''");\n        }\n\n        switch (suckFactor) {\n        case 1:\n            System.out.println("This sucks");\n            break;\n        case 2:\n            System.out.println("This really sucks");\n            break;\n        case 3:\n            System.out.println("This seriously sucks");\n            break;\n        default:\n            System.out.println("whatever");\n            break;\n        }\n\n        if (superHero == theTick) {\n            System.out.println("Spoon!");\n        }\n\n        foo(i, j);\n\n        a = b + c;\n        z = (2 * x) + (3 * y);\n        count++;\n        i--;\n\n        for (int i = 0; i < 10; i++) {\n            getPancakes(syrupQuantity, butterQuantity);\n        }\n\n        (MyClass) v.get(3);\n\n        if (hungry) {\n            while (pancakes < 7) {\n                for (int i = 0; i < 10; i++) {\n                    try {\n                    } catch(TooManyPancakesException e) {\n                    }\n                }\n\n            }\n        }\n\n        foo(x);                 // YES!\n        x++;\n\n        y += 100 * x;           // YES!\n        x++;\n\n        /*\n         * "Any fool can write code that a computer can understand. Good\n         * programmers write code that humans can understand." --- Martin\n         * Fowler, Refactoring: Improving the Design of Existing Code \n         */\n        int             secondWide = 12;\n        int             firstWide = doFoo(20, secondWide);\n        doBar(firstWide, secondWide);\n        int             totalWide = firstWide + secondWide;\n\n    }\n\n    void            tooLongMethod() {\n        boolean         isTickSidekick = ((sidekick == arthur)\n                                          || (sidekick == speak));\n        if ((hero == theTick) && isTickSidekick) {\n        }\n    }\n\n    public static void happyBirthday(int age) { // WRONG!\n        // If you''re in the US, some birthdays are special:\n        // 16 (sweet sixteen)\n        // 21 (age of majority)\n        // 25, 50, 75 (quarter centuries)\n        // 30, 40, 50, ... etc (decades)\n        if ((age == 16) || (age == 21)\n            || ((age > 21) && (((age % 10) == 0) || ((age % 25) == 0)))) {\n            System.out.println("Super special party, this year!");\n        } else {\n            System.out.println("One year older. Again.");\n        }\n    }\n\n    public static void happyBirthday(int age) { // Right!\n        boolean         sweet_sixteen = (age == 16);\n        boolean         majority = (age == 21);\n        boolean         adult = (age > 21);\n        boolean         decade = (age % 10) == 0;\n        boolean         quarter = (age % 25) == 0;\n\n        if (sweet_sixteen || majority || (adult && (decade || quarter))) {\n            System.out.println("Super special party, this year!");\n        } else {\n            System.out.println("One year older. Again.");\n        }\n    }\n\n    // This actualy work amazing for debuging\n    static void     dbg(Object ... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n\n    static void     callingDebug() {\n        dbg(3);\n        String[]b = new String[] {\n            "Sunday",           // Sunday\n                "Monday",       // Monday\n                "Tuesday",      // Tuesday\n                "Wednesday",    // Wednesday\n                "Thursday",     // Thursday\n                "Friday",       // Friday\n                "Saturday"      // Saturday\n        };\n        dbg(b);\n        HashMap < String, Person > ha = new HashMap < String, Person > ();\n        Person          him = new Person().sFirstName = "civilian";\n        ha.put("Oscar", him);\n        dbg(ha);\n        // dbg(Whatever_i_want_as_long_as_the_objet_has_an_toString_method);\n\n    }\n\n    static class    Person {\n\n        private String  sFirstName;     // NO! (Hungarian notation: s for\n        // String)\n        private String  firstName;      // YES!\n        private String  mLastName;      // NO! (Scope identification: m\n        // for member variable)\n        private String  _lastName;      // NO! (Scope identification: _\n        // for member variable)\n        private String  lastName;       // YES!\n\n        // ...\n                       @Override public String toString() {\n            return "Person{" + "sFirstName=" + sFirstName +\n                ", firstName=" + firstName + ", mLastName=" +\n                mLastName + ", _lastName=" + _lastName +\n                ", lastName=" + lastName + ''}'';\n        }\n    }\n    private static final File getDestinationFile(File dest,\n                                                 String packageName,\n                                                 String filename, int prio)\n    throws          IOException,\n                    FooException {\n        switch (prio) {\n        case Priority.ERROR_INT:\n        case Priority.FATAL_INT:\n            color = Color.red;\n            break;\n\n            case Priority.WARN_INT:color = Color.blue;\n            break;\n\n            default:color = Color.black;\n            break;\n        }\n        return          null;\n    }\n\n    public void     severalParameters(String one, int two, String three,\n                                      StringObject four,\n                                      AnotherObject five) {\n\n        if ((condition1 && condition2)\n            || (condition3 && condition4) || !(condition5 && condition6)) {\n            doSomethingAboutIt();\n        }\n\n        vector.add(new AppServerReference("RemoteApplicationManager",\n                                          poa.create_reference_with_id\n                                          ("RemoteApplicationManager".getBytes\n                                           (),\n                                           RemoteApplicationManagerHelper.id\n                                           ())));\n\n        doublette[InteressentenPflegeController.GEBURTSDATUM] =\n            versichertenResultSetRow[i].field[0].substring(0,\n                                                           2) + "."\n            + versichertenResultSetRow[i].field[0].substring(2,\n                                                             4) + "."\n            + versichertenResultSetRow[i].field[0].substring(4, 6);\n    }\n\n    public static void main(String[]argv) {\n        callingDebug();\n    }\n\n    @Override public void run() {\n        throw new      \n            UnsupportedOperationException("Not supported yet.");\n    }\n}\n'),
(12, 'java', 'kr', '// This sample doesn''t compile but help''s but showing the differente code \n// snippets that help you keep the indentation style\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport javax.swing.JFrame;\n\npublic class sample extends JFrame implements Runnable {\n\n    String[] a = new String[] {\n        "Sunday",               // Sunday\n            "Monday",           // Monday\n            "Tuesday",          // Tuesday\n            "Wednesday",        // Wednesday\n            "Thursday",         // Thursday\n            "Friday",           // Friday\n            "Saturday"          // Saturday\n    };\n\n    private sample() {\n    }\n\n    void foo() {\n        while (bar > 0) {\n            System.out.println();\n            bar--;\n        }\n\n        if (oatmeal == tasty) {\n            System.out.println("Oatmeal is good and good for you");\n        } else if (oatmeal == yak) {\n            System.out.println("Oatmeal tastes like sawdust");\n        } else {\n            System.out.println("tell me pleeze what iz dis ''oatmeal''");\n        }\n\n        switch (suckFactor) {\n        case 1:\n            System.out.println("This sucks");\n            break;\n        case 2:\n            System.out.println("This really sucks");\n            break;\n        case 3:\n            System.out.println("This seriously sucks");\n            break;\n        default:\n            System.out.println("whatever");\n            break;\n        }\n\n        if (superHero == theTick) {\n            System.out.println("Spoon!");\n        }\n\n        foo(i, j);\n\n        a = b + c;\n        z = (2 * x) + (3 * y);\n        count++;\n        i--;\n\n        for (int i = 0; i < 10; i++) {\n            getPancakes(syrupQuantity, butterQuantity);\n        }\n\n        (MyClass) v.get(3);\n\n        if (hungry) {\n            while (pancakes < 7) {\n                for (int i = 0; i < 10; i++) {\n                    try {\n                    } catch(TooManyPancakesException e) {\n                    }\n                }\n\n            }\n        }\n\n        foo(x);                 // YES!\n        x++;\n\n        y += 100 * x;           // YES!\n        x++;\n\n        /*\n         * "Any fool can write code that a computer can understand. Good\n         * programmers write code that humans can understand." --- Martin\n         * Fowler, Refactoring: Improving the Design of Existing Code \n         */\n        int secondWide = 12;\n        int firstWide = doFoo(20, secondWide);\n        doBar(firstWide, secondWide);\n        int totalWide = firstWide + secondWide;\n\n    }\n\n    void tooLongMethod() {\n        boolean isTickSidekick = ((sidekick == arthur)\n                                  || (sidekick == speak));\n        if ((hero == theTick) && isTickSidekick) {\n        }\n    }\n\n    public static void happyBirthday(int age) { // WRONG!\n        // If you''re in the US, some birthdays are special:\n        // 16 (sweet sixteen)\n        // 21 (age of majority)\n        // 25, 50, 75 (quarter centuries)\n        // 30, 40, 50, ... etc (decades)\n        if ((age == 16) || (age == 21)\n            || ((age > 21) && (((age % 10) == 0) || ((age % 25) == 0)))) {\n            System.out.println("Super special party, this year!");\n        } else {\n            System.out.println("One year older. Again.");\n        }\n    }\n\n    public static void happyBirthday(int age) { // Right!\n        boolean sweet_sixteen = (age == 16);\n        boolean majority = (age == 21);\n        boolean adult = (age > 21);\n        boolean decade = (age % 10) == 0;\n        boolean quarter = (age % 25) == 0;\n\n        if (sweet_sixteen || majority || (adult && (decade || quarter))) {\n            System.out.println("Super special party, this year!");\n        } else {\n            System.out.println("One year older. Again.");\n        }\n    }\n\n    // This actualy work amazing for debuging\n    static void dbg(Object ... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n\n    static void callingDebug() {\n        dbg(3);\n        String[]b = new String[] {\n            "Sunday",           // Sunday\n                "Monday",       // Monday\n                "Tuesday",      // Tuesday\n                "Wednesday",    // Wednesday\n                "Thursday",     // Thursday\n                "Friday",       // Friday\n                "Saturday"      // Saturday\n        };\n        dbg(b);\n        HashMap < String, Person > ha = new HashMap < String, Person > ();\n        Person him = new Person().sFirstName = "civilian";\n        ha.put("Oscar", him);\n        dbg(ha);\n        // dbg(Whatever_i_want_as_long_as_the_objet_has_an_toString_method);\n\n    }\n\n    static class Person {\n\n        private String sFirstName;      // NO! (Hungarian notation: s for\n        // String)\n        private String firstName;       // YES!\n        private String mLastName;       // NO! (Scope identification: m\n        // for member variable)\n        private String _lastName;       // NO! (Scope identification: _\n        // for member variable)\n        private String lastName;        // YES!\n\n        // ...\n        @Override public String toString() {\n            return "Person{" + "sFirstName=" + sFirstName +\n                ", firstName=" + firstName + ", mLastName=" +\n                mLastName + ", _lastName=" + _lastName +\n                ", lastName=" + lastName + ''}'';\n        }\n    }\n    private static final File getDestinationFile(File dest,\n                                                 String packageName,\n                                                 String filename, int prio)\n    throws IOException, FooException {\n        switch (prio) {\n        case Priority.ERROR_INT:\n        case Priority.FATAL_INT:\n            color = Color.red;\n            break;\n\n            case Priority.WARN_INT:color = Color.blue;\n            break;\n\n            default:color = Color.black;\n            break;\n        }\n        return null;\n    }\n\n    public void severalParameters(String one, int two, String three,\n                                  StringObject four, AnotherObject five) {\n\n        if ((condition1 && condition2)\n            || (condition3 && condition4) || !(condition5 && condition6)) {\n            doSomethingAboutIt();\n        }\n\n        vector.add(new AppServerReference("RemoteApplicationManager",\n                                          poa.create_reference_with_id\n                                          ("RemoteApplicationManager".getBytes\n                                           (),\n                                           RemoteApplicationManagerHelper.id\n                                           ())));\n\n        doublette[InteressentenPflegeController.GEBURTSDATUM] =\n            versichertenResultSetRow[i].field[0].substring(0,\n                                                           2) + "."\n            + versichertenResultSetRow[i].field[0].substring(2,\n                                                             4) + "."\n            + versichertenResultSetRow[i].field[0].substring(4, 6);\n    }\n\n    public static void main(String[]argv) {\n        callingDebug();\n    }\n\n    @Override public void run() {\n        throw new UnsupportedOperationException("Not supported yet.");\n    }\n}\n');

-- 
-- Dumping data for table `language`
-- 

INSERT INTO `language` (`langid`, `name`, `allow_submit`, `allow_judge`, `time_factor`) VALUES ('c', 'C', 0, 1, 1);
INSERT INTO `language` (`langid`, `name`, `allow_submit`, `allow_judge`, `time_factor`) VALUES ('cpp', 'C++', 1, 1, 1);
INSERT INTO `language` (`langid`, `name`, `allow_submit`, `allow_judge`, `time_factor`) VALUES ('java', 'Java', 1, 1, 1.5);
INSERT INTO `language` (`langid`, `name`, `allow_submit`, `allow_judge`, `time_factor`) VALUES ('pas', 'Pascal', 0, 1, 1);
INSERT INTO `language` (`langid`, `name`, `allow_submit`, `allow_judge`, `time_factor`) VALUES ('hs', 'Haskell', 0, 1, 2);
INSERT INTO `language` (`langid`, `name`, `allow_submit`, `allow_judge`, `time_factor`) VALUES ('pl', 'Perl', 0, 1, 1);
INSERT INTO `language` (`langid`, `name`, `allow_submit`, `allow_judge`, `time_factor`) VALUES ('sh', 'POSIX shell', 0, 1, 1);
INSERT INTO `language` (`langid`, `name`, `allow_submit`, `allow_judge`, `time_factor`) VALUES ('bash', 'Bash shell', 0, 1, 1);
INSERT INTO `language` (`langid`, `name`, `allow_submit`, `allow_judge`, `time_factor`) VALUES ('csharp', 'C#', 0, 1, 1);
INSERT INTO `language` (`langid`, `name`, `allow_submit`, `allow_judge`, `time_factor`) VALUES ('awk', 'AWK', 0, 1, 1);
INSERT INTO `language` (`langid`, `name`, `allow_submit`, `allow_judge`, `time_factor`) VALUES ('py2', 'Python 2', 0, 1, 1);
INSERT INTO `language` (`langid`, `name`, `allow_submit`, `allow_judge`, `time_factor`) VALUES ('py3', 'Python 3', 0, 1, 1);
INSERT INTO `language` (`langid`, `name`, `allow_submit`, `allow_judge`, `time_factor`) VALUES ('adb',    'Ada',     0, 1, 1);
INSERT INTO `language` (`langid`, `name`, `allow_submit`, `allow_judge`, `time_factor`) VALUES ('f95',    'Fortran', 0, 1, 1);
INSERT INTO `language` (`langid`, `name`, `allow_submit`, `allow_judge`, `time_factor`) VALUES ('scala',  'Scala',   0, 1, 1.5);
INSERT INTO `language` (`langid`, `name`, `allow_submit`, `allow_judge`, `time_factor`) VALUES ('lua',    'Lua',     0, 1, 1);
INSERT INTO `language` (`langid`, `name`, `allow_submit`, `allow_judge`, `time_factor`) VALUES ('scheme', 'Racket 5.3.6 \\ drScheme', 1, 1, 1);
-- 
-- Dumping data for table `team_category`
-- 
-- System category
INSERT INTO `team_category` VALUES (1, 'System', 9, '#ff2bea', 0);

-- 
-- Dumping data for table `team`
-- 

INSERT INTO `team` (`login`, `name`, `categoryid`, `affilid`, `authtoken`, `hostname`, `room`, `comments`, `teampage_first_visited`) VALUES ('domjudge', 'DOMjudge', 1, NULL, '127.0.0.1', NULL, NULL, NULL, NULL);

